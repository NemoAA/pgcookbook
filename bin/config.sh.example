#!/bin/bash

# config.sh.example - example configuration.
#
# Rename it to config.sh and adjust the settings for your needs.
#
# Settings can be written in the form
#
#     test -z $SETTING && SETTING='value'
#
# that means you can also set them from the command line, eg.
#
#     SETTING='another value' bin/some_script.sh
#
# Copyright (c) 2013-2014 Sergey Konoplev
#
# Sergey Konoplev <gray.ru@gmail.com>

test -z $HOST && HOST=
test -z $PORT && PORT=
test -z $USER && USER=

DSN="$(test ! -z $HOST && echo '-h' $HOST) \
     $(test ! -z $PORT && echo '-p' $PORT) \
     $(test ! -z $USER && echo '-U' $USER)"

PSQL="/usr/bin/psql $DSN"
PGDUMP="/usr/bin/pg_dump $DSN"
PGRESTORE="/usr/bin/pg_restore $DSN"
PGDUMPALL="/usr/bin/pg_dumpall $DSN"
RSYNC='/usr/bin/rsync -aq'
SSH='/usr/bin/ssh'

test -z $TUNNEL_PORT && TUNNEL_PORT=2345
test -z $TUNNEL_HOST_PORT && TUNNEL_HOST_PORT=5432
test -z $TUNNEL_HOST && TUNNEL_HOST='host2'
TUNNEL_COMP_LEVEL=2
TUNNEL_RETRY_DELAY=60
test -z $TUNNEL_LOCK_FILE && \
    TUNNEL_LOCK_FILE="/tmp/ssh_tunnel.$TUNNEL_HOST.$TUNNEL_HOST_PORT"

DUMPS_DBNAME_LIST='dbname1 dbname2'
DUMPS_LOCAL_DIR=
DUMPS_ARCHIVE_DIR='/storage/dumps'
DUMPS_KEEP_DAILY_PARTS='3 days'
DUMPS_KEEP_WEEKLY_PARTS='1 month'
DUMPS_KEEP_MONTHLY_PARTS='1 year'

test -z $RESTORE_DROP && RESTORE_DROP=true
test -z $RESTORE_DBNAME && RESTORE_DBNAME='dbname2_latest'
test -z $RESTORE_FILE && \
    RESTORE_FILE=$( \
        find $DUMPS_ARCHIVE_DIR -maxdepth 1 -mindepth 1 | \
        sort | tail -n 1)'/dbname2.dump.gz'
RESTORE_THREADS=4
RESTORE_FILTER_MASK=$(cat <<EOF
temp1|temp2
EOF
)
RESTORE_FILTER_SQL=$(cat <<EOF
    SELECT schemaname, tablename FROM pg_tables
    WHERE tablename ~ '$RESTORE_FILTER_MASK'
EOF
)
RESTORE_FILTER_DATA_MASK=$(cat <<EOF
log1|log2
EOF
)
RESTORE_FILTER_DATA_SQL=$(cat <<EOF
    SELECT schemaname, tablename FROM pg_tables
    WHERE tablename ~ '$RESTORE_FILTER_DATA_MASK'
EOF
)
RESTORE_FILTER_DATA_PART_MASK=$(cat <<EOF
data1|data2
EOF
)
RESTORE_FILTER_DATA_PART_COND=$(cat <<EOF
status <> 1 OR deleted
EOF
)
RESTORE_FILTER_DATA_PART_SQL=$(cat <<EOF
    SELECT
        schemaname, tablename,
        '$RESTORE_FILTER_DATA_PART_COND' AS conditions
    FROM pg_tables
    WHERE tablename ~ '$RESTORE_FILTER_DATA_PART_MASK'
EOF
)

ARCHIVE_DBNAME_LIST='dbname1 dbname2'
ARCHIVE_LOCAL_DIR=
ARCHIVE_ARCHIVE_DIR='/storage/parts'
ARCHIVE_TYPE1_PARTS_KEEP='1 year'
ARCHIVE_TYPE1_PARTS_MASK=$(cat <<EOF
table1|table2
EOF
)
ARCHIVE_TYPE2_PARTS_KEEP='2 years'
ARCHIVE_TYPE2_PARTS_MASK=$(cat <<EOF
table3|table4
EOF
)
ARCHIVE_PARTS_SQL=$(cat <<EOF
    SELECT schemaname, tablename
    FROM pg_tables
    WHERE
        tablename ~ E'($ARCHIVE_TYPE1_PARTS_MASK)_\\\\d{4}\\\\d{2}$' AND
        to_timestamp(
            regexp_replace(tablename, '^.+_', ''),
            'YYYYMM') < date_trunc('month', now()) -
            '$ARCHIVE_TYPE1_PARTS_KEEP'::interval
    UNION
    SELECT schemaname, tablename
    FROM pg_tables
    WHERE
        tablename ~ E'($ARCHIVE_TYPE2_PARTS_MASK)_\\\\d{4}\\\\d{2}$' AND
        to_timestamp(
            regexp_replace(tablename, '^.+_', ''),
            'YYYYMM') < date_trunc('month', now()) -
            '$ARCHIVE_TYPE2_PARTS_KEEP'::interval
EOF
)
function ARCHIVE_COMMAND_BEFORE_DROP() {
    /usr/bin/londiste /etc/skytools/londiste-host2-$1.ini provider remove $2
}
function ARCHIVE_COMMAND_AFTER_DROP() {
    $PSQL -h host2 $1 -c "DROP TABLE $2"
}

STAT_DBNAME='dbname1'
test -z $STAT_REPLICA_DSN && STAT_REPLICA_DSN=
test -z $STAT_SNAPSHOT && STAT_SNAPSHOT=false
test -z $STAT_SINCE && STAT_SINCE=$(date -I)
test -z $STAT_TILL && STAT_TILL=$(date -I --date='+1 day')
test -z $STAT_N && STAT_N=10
test -z $STAT_ORDER && STAT_ORDER=0
STAT_KEEP_SNAPSHOTS='7 days'

TERMINATE_CONDITIONS=$(cat <<EOF
state <> 'idle' AND -- Recommended due to a pg_stat_activity bug when
                    -- sometimes state is not in sync with xact_start.
                    -- Makes sence for >=9.2.
(
    (
        usename IN ('user1', 'user2') AND
        now() - xact_start > '10 second'::interval
    ) OR (
        usename NOT IN ('postgres') AND
        now() - xact_start > '180 second'::interval
    )
)
EOF
)

test -z $PROCESS_DBNAME && PROCESS_DBNAME=

LAG_DBNAME='dbname1'
test -z $LAG_DSN && LAG_DSN=
LAG_RECEIVE=$((32 * 1024 * 1024))
LAG_REPLAY=$((32 * 1024 * 1024))
LAG_REPLAY_AGE='5 minutes'
